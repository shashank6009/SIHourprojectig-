{"version":3,"sources":["turbopack:///[project]/src/lib/analytics.ts","turbopack:///[project]/src/lib/privacy.ts","turbopack:///[project]/src/app/api/ats/inspect/route.ts","turbopack:///[project]/node_modules/next/dist/esm/build/templates/app-route.js","turbopack:///[project]/src/lib/ats.ts"],"sourcesContent":["import { supabaseServer } from './supabase-server';\nimport { hashUserId, sanitizeMetadata } from './privacy';\n\nexport type EventType = \n  | \"INTERVIEW_COMPLETED\" \n  | \"JD_ALIGNED\" \n  | \"PDF_EXPORTED\" \n  | \"COMMENT_ADDED\" \n  | \"COMMENT_RESOLVED\" \n  | \"MENTOR_APPROVED\"\n  | \"BATCH_CREATED\"\n  | \"BATCH_ITEM_COMPLETED\"\n  | \"BATCH_EXPORTED\"\n  | \"EMAIL_DRAFT_CREATED\"\n  | \"FOLLOWUP_SCHEDULED\"\n  | \"ATS_CHECKLIST_VIEWED\"\n  | \"REFERRAL_INTRO_DRAFTED\"\n  | \"REFERRAL_IMPORTED\"\n  | \"CONSENT_GRANTED\"\n  | \"CONSENT_REVOKED\"\n  | \"DSR_EXPORT_REQUESTED\"\n  | \"DSR_DELETE_REQUESTED\"\n  | \"PRIVACY_REGION_SET\";\n\nexport interface EventMetadata {\n  [key: string]: any;\n}\n\n/**\n * Track user events for analytics and continuous improvement\n * All PII is hashed and metadata is sanitized for privacy\n */\nexport async function trackEvent(args: {\n  userId: string;\n  event: EventType;\n  resumeVersionId?: string;\n  metadata?: EventMetadata;\n}): Promise<void> {\n  try {\n    const { userId, event, resumeVersionId, metadata = {} } = args;\n    \n    // Hash user ID for privacy\n    const userHash = hashUserId(userId);\n    \n    // Sanitize metadata to remove PII and limit size\n    const sanitizedMetadata = sanitizeMetadata(metadata);\n    \n    // Insert event into database\n    const { error } = await supabaseServer\n      .from('resume_events')\n      .insert({\n        user_hash: userHash,\n        resume_version_id: resumeVersionId || null,\n        event_type: event,\n        metadata: sanitizedMetadata,\n      });\n    \n    if (error) {\n      console.error('Failed to track event:', error);\n      // Don't throw - analytics failures shouldn't break user flows\n    }\n  } catch (error) {\n    console.error('Analytics tracking error:', error);\n    // Silently fail to avoid breaking user experience\n  }\n}\n\n/**\n * Get user events for a specific time range\n * Used for analytics and debugging\n */\nexport async function getUserEvents(\n  userId: string,\n  startDate?: string,\n  endDate?: string,\n  eventType?: EventType\n): Promise<any[]> {\n  try {\n    const userHash = hashUserId(userId);\n    \n    let query = supabaseServer\n      .from('resume_events')\n      .select('*')\n      .eq('user_hash', userHash)\n      .order('created_at', { ascending: false });\n    \n    if (startDate) {\n      query = query.gte('created_at', startDate);\n    }\n    \n    if (endDate) {\n      query = query.lte('created_at', endDate);\n    }\n    \n    if (eventType) {\n      query = query.eq('event_type', eventType);\n    }\n    \n    const { data, error } = await query.limit(100);\n    \n    if (error) {\n      console.error('Failed to fetch user events:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (error) {\n    console.error('Error fetching user events:', error);\n    return [];\n  }\n}\n\n/**\n * Get aggregated metrics for a date range\n */\nexport async function getMetrics(\n  startDate: string,\n  endDate: string,\n  userHash?: string\n): Promise<any[]> {\n  try {\n    let query = supabaseServer\n      .from('resume_metrics_daily')\n      .select('*')\n      .gte('day', startDate)\n      .lte('day', endDate)\n      .order('day', { ascending: false });\n    \n    if (userHash) {\n      query = query.eq('user_hash', userHash);\n    }\n    \n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Failed to fetch metrics:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (error) {\n    console.error('Error fetching metrics:', error);\n    return [];\n  }\n}\n\n/**\n * Track model run for audit and improvement\n */\nexport async function trackModelRun(args: {\n  userId: string;\n  resumeVersionId?: string;\n  provider: string;\n  model: string;\n  promptKey: string;\n  tokensIn?: number;\n  tokensOut?: number;\n  atsScore?: number;\n  missingKeywords?: number;\n}): Promise<void> {\n  try {\n    const { userId, resumeVersionId, provider, model, promptKey, tokensIn, tokensOut, atsScore, missingKeywords } = args;\n    \n    const userHash = hashUserId(userId);\n    \n    const { error } = await supabaseServer\n      .from('resume_model_runs')\n      .insert({\n        user_hash: userHash,\n        resume_version_id: resumeVersionId || null,\n        provider,\n        model,\n        prompt_key: promptKey,\n        tokens_in: tokensIn || 0,\n        tokens_out: tokensOut || 0,\n        ats_score: atsScore || null,\n        missing_keywords: missingKeywords || 0,\n      });\n    \n    if (error) {\n      console.error('Failed to track model run:', error);\n    }\n  } catch (error) {\n    console.error('Model run tracking error:', error);\n  }\n}\n","import { createHash } from 'crypto';\n\n/**\n * Hash user ID for privacy-safe analytics\n * Uses SHA-256 to create a consistent hash that can't be reversed\n */\nexport function hashUserId(raw: string): string {\n  if (!raw) return '';\n  \n  // Use Node.js crypto for server-side hashing\n  return createHash('sha256').update(raw).digest('hex');\n}\n\n/**\n * Redact PII from text for safe logging\n * Removes emails, phone numbers, and other sensitive data\n */\nexport function redactPII(text: string): string {\n  if (!text) return '';\n  \n  let redacted = text;\n  \n  // Remove email addresses\n  redacted = redacted.replace(/\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g, '[email]');\n  \n  // Remove phone numbers (various formats)\n  redacted = redacted.replace(/\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/g, '[phone]');\n  redacted = redacted.replace(/\\b\\(\\d{3}\\)\\s*\\d{3}[-.]?\\d{4}\\b/g, '[phone]');\n  redacted = redacted.replace(/\\b\\d{3}\\s\\d{3}\\s\\d{4}\\b/g, '[phone]');\n  \n  // Remove SSN patterns (basic)\n  redacted = redacted.replace(/\\b\\d{3}-\\d{2}-\\d{4}\\b/g, '[ssn]');\n  redacted = redacted.replace(/\\b\\d{9}\\b/g, '[ssn]');\n  \n  // Remove credit card patterns (basic)\n  redacted = redacted.replace(/\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b/g, '[card]');\n  \n  return redacted;\n}\n\n/**\n * Sanitize metadata for safe storage\n * Ensures metadata is JSON-safe and within size limits\n */\nexport function sanitizeMetadata(metadata: Record<string, any>): Record<string, any> {\n  if (!metadata || typeof metadata !== 'object') return {};\n  \n  const sanitized: Record<string, any> = {};\n  \n  for (const [key, value] of Object.entries(metadata)) {\n    // Skip if key is too long or contains sensitive patterns\n    if (key.length > 50 || /password|secret|token|key/i.test(key)) {\n      continue;\n    }\n    \n    // Handle different value types\n    if (typeof value === 'string') {\n      // Redact PII from strings and limit length\n      sanitized[key] = redactPII(value).substring(0, 500);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      sanitized[key] = value;\n    } else if (Array.isArray(value)) {\n      // Limit array size and sanitize each element\n      sanitized[key] = value.slice(0, 10).map(item => \n        typeof item === 'string' ? redactPII(item).substring(0, 100) : item\n      );\n    } else if (typeof value === 'object' && value !== null) {\n      // Recursively sanitize nested objects (limited depth)\n      sanitized[key] = sanitizeMetadata(value);\n    }\n  }\n  \n  // Ensure total size is under 2KB\n  const jsonString = JSON.stringify(sanitized);\n  if (jsonString.length > 2000) {\n    // Truncate by removing largest values\n    const entries = Object.entries(sanitized).sort((a, b) => \n      JSON.stringify(b[1]).length - JSON.stringify(a[1]).length\n    );\n    \n    const truncated: Record<string, any> = {};\n    let currentSize = 0;\n    \n    for (const [key, value] of entries) {\n      const entrySize = JSON.stringify({ [key]: value }).length;\n      if (currentSize + entrySize < 1800) { // Leave some buffer\n        truncated[key] = value;\n        currentSize += entrySize;\n      }\n    }\n    \n    return truncated;\n  }\n  \n  return sanitized;\n}\n","import { NextRequest, NextResponse } from 'next/server';\nimport { analyzeJobURL } from '@/lib/ats';\nimport { trackEvent } from '@/lib/analytics';\nimport { z } from 'zod';\n\nconst InspectRequestSchema = z.object({\n  jdUrl: z.string().url(),\n});\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { jdUrl } = InspectRequestSchema.parse(body);\n\n    // For now, use a placeholder user ID (replace with real auth later)\n    const userId = 'placeholder-user-id';\n\n    // Analyze the job URL\n    const atsInfo = analyzeJobURL(jdUrl);\n\n    // Track the ATS inspection\n    await trackEvent({\n      userId,\n      event: 'ATS_CHECKLIST_VIEWED',\n      metadata: {\n        ats: atsInfo.ats,\n        url: jdUrl,\n      },\n    });\n\n    return NextResponse.json({\n      ats: atsInfo.ats,\n      applyUrl: atsInfo.applyUrl,\n      checklist: atsInfo.checklist,\n    });\n  } catch (error) {\n    console.error('Error inspecting ATS:', error);\n    \n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { error: 'Invalid request data', details: error.errors },\n        { status: 400 }\n      );\n    }\n\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/ats/inspect/route\",\n        pathname: \"/api/ats/inspect\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/ats/inspect/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/ats/inspect/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!getRequestMeta(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!getRequestMeta(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(getRequestMeta(req, 'minimalMode') && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","/**\n * ATS (Applicant Tracking System) Helpers\n * Detects ATS platforms and provides application checklists\n */\n\nexport type ATSPlatform = 'greenhouse' | 'lever' | 'workday' | 'unknown';\n\nexport interface ATSInfo {\n  ats: ATSPlatform;\n  applyUrl: string;\n  checklist: string[];\n}\n\n/**\n * Detect ATS platform from job URL\n */\nexport function detectATS(url: string): ATSPlatform {\n  const urlLower = url.toLowerCase();\n  \n  if (urlLower.includes('greenhouse.io') || urlLower.includes('boards.greenhouse.io')) {\n    return 'greenhouse';\n  }\n  \n  if (urlLower.includes('lever.co') || urlLower.includes('jobs.lever.co')) {\n    return 'lever';\n  }\n  \n  if (urlLower.includes('workday.com') || urlLower.includes('myworkdayjobs.com')) {\n    return 'workday';\n  }\n  \n  return 'unknown';\n}\n\n/**\n * Normalize apply URL for better tracking\n */\nexport function normalizeApplyLink(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    \n    // Remove tracking parameters\n    const trackingParams = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content', 'ref', 'source'];\n    trackingParams.forEach(param => {\n      urlObj.searchParams.delete(param);\n    });\n    \n    return urlObj.toString();\n  } catch (error) {\n    return url; // Return original if URL parsing fails\n  }\n}\n\n/**\n * Get application checklist for specific ATS\n */\nexport function checklistForATS(kind: ATSPlatform): string[] {\n  const baseChecklist = [\n    'Review job requirements carefully',\n    'Prepare tailored resume and cover letter',\n    'Gather relevant portfolio/work samples',\n    'Prepare for behavioral questions',\n  ];\n\n  switch (kind) {\n    case 'greenhouse':\n      return [\n        ...baseChecklist,\n        'Answer knockout questions honestly',\n        'Upload resume as PDF',\n        'Paste cover letter in text field',\n        'Complete all required fields',\n        'Confirm location eligibility',\n        'Review application before submitting',\n      ];\n    \n    case 'lever':\n      return [\n        ...baseChecklist,\n        'Complete application form thoroughly',\n        'Upload resume and cover letter',\n        'Answer screening questions',\n        'Provide LinkedIn profile if requested',\n        'Confirm availability and start date',\n        'Double-check contact information',\n      ];\n    \n    case 'workday':\n      return [\n        ...baseChecklist,\n        'Create/update Workday profile',\n        'Upload resume and documents',\n        'Complete all application sections',\n        'Answer assessment questions if any',\n        'Confirm work authorization status',\n        'Review and submit application',\n      ];\n    \n    default:\n      return [\n        ...baseChecklist,\n        'Follow application instructions carefully',\n        'Submit all required documents',\n        'Complete all form fields',\n        'Review application thoroughly',\n      ];\n  }\n}\n\n/**\n * Get ATS-specific tips\n */\nexport function getATSTips(kind: ATSPlatform): string[] {\n  switch (kind) {\n    case 'greenhouse':\n      return [\n        'Greenhouse uses keyword matching - include relevant skills from the job description',\n        'Answer knockout questions carefully - they filter candidates automatically',\n        'Upload your resume as a PDF for better parsing',\n        'Use standard section headers in your resume (Experience, Education, Skills)',\n      ];\n    \n    case 'lever':\n      return [\n        'Lever values cultural fit - highlight relevant experiences and values',\n        'Complete all optional fields to show thoroughness',\n        'Use action verbs and quantify achievements in your resume',\n        'Tailor your cover letter to the specific role and company',\n      ];\n    \n    case 'workday':\n      return [\n        'Workday requires complete profiles - fill out all sections thoroughly',\n        'Use consistent formatting in your resume',\n        'Include relevant keywords from the job description',\n        'Complete any required assessments honestly and thoroughly',\n      ];\n    \n    default:\n      return [\n        'Focus on relevant keywords from the job description',\n        'Use clear, professional formatting',\n        'Quantify your achievements with numbers',\n        'Tailor your application to the specific role',\n      ];\n  }\n}\n\n/**\n * Analyze job URL and return comprehensive ATS information\n */\nexport function analyzeJobURL(url: string): ATSInfo {\n  const ats = detectATS(url);\n  const applyUrl = normalizeApplyLink(url);\n  const checklist = checklistForATS(ats);\n  \n  return {\n    ats,\n    applyUrl,\n    checklist,\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[3]}